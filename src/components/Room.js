/** * Created by chhiggin on 7/11/17. */import React, {Component} from "react"import Chat from "./Chat.js"import ProgressBarMusic from "./ProgressBar.js"import ReactTable from "react-table"import Player from "react-sound"import Upload from "react-dropzone"import Spinner from "react-spinkit"import firebase from "../index.js"import ProgressBarUpload from "react-progressbar.js"import "react-table/react-table.css"import "../css/Room.css"class Room extends Component {	constructor(props) {		super(props)		this.state = {			uploading:      null, //Object of uploading track data ref by fb key			uploadProgress: 0,			loading:        true,			loaded:         0,			position:       0,			isPlaying:      false,		}		this.roomId = props.match.params.roomId		this.db = firebase.database().ref()		this.user = firebase.auth().currentUser		this.storage = firebase.storage().ref()		this.handleUploads = this.handleUploads.bind(this)		this.trackEnded = this.trackEnded.bind(this)		this.onPlaying = this.onPlaying.bind(this)	}	static queueColumns = [{		Header:    null,		resizable: false,		width:     24,		accessor:  'pending',		Cell:      props => props.value ? <Spinner name="pulse" fadeIn={'none'} className="track-spinner"/> : null,		className: 'pending'	}, {		Header:   'Title',		accessor: 'title'	}, {		Header:   'Artist',		accessor: 'artist'	}, {		Header:   'Album',		accessor: 'album'	}, {		Header:    'Time',		accessor:  'duration',		resizable: false,		width:     60,	}]	handleUploads(accepted, rejected) {		if (accepted.length) {			const files = accepted.map(file => {				return file.name			})			accepted.forEach(file => {				this.getMetadata(file, {duration: true}) //need another solution for getting duration				.then(metadata => {					const songObj = {						name:     file.name,						album:    metadata.album,						artist:   metadata.artist[0],						title:    metadata.title,						year:     metadata.year,						duration: metadata.duration,						pending:  true,					}					// Create song key and data					const sDataRef = this.db.child('song_data/' + this.roomId).push()					const key = sDataRef.getKey()					sDataRef.set(songObj)					// Add to local uploads					this.setState(ps => {						return {							uploading: {								...ps.uploading,								[key]: {									totalBytes: file.size,									...songObj,								}							}						}					})					// Tell the database you're about to be uploading something					const sUploadedRef = this.db.child('room_data/' + this.roomId + '/songs/uploaded/' + key)					const sPendingRef = this.db.child('room_data/' + this.roomId + '/songs/pending/' + key)					sPendingRef.onDisconnect().remove()					sPendingRef.set(true)					// Upload art if there is any					if (metadata.picture && metadata.picture[0]) {						this.storage.child(`art/${file.name}.${metadata.picture[0].format}`).put(metadata.picture[0].data)						.then(ss => {							// Put the art URL into the song data							this.db.child(`song_data/${this.roomId}/${key}/albumURL`).set(ss.downloadURL)							this.setState(ps => {								return {									uploading: {										...ps.uploading,										[key]: {...ps.uploading[key], albumURL: ss.downloadURL}									}								}							})						})					}					// Start file upload					const uploadSongTask = this.storage.child('songs/' + file.name).put(file)					// Track the upload status					uploadSongTask.on('state_changed', ss => {						this.setState(ps => {							return {								uploading: {									...ps.uploading,									[key]: {...ps.uploading[key], bytesTransferred: ss.bytesTransferred}								}							}						})					})					// Once upload is completed...					uploadSongTask.then(ss => {						// Remove it from the uploading state (local)						let newState = {}						this.setState(ps => {							Object.keys(ps.uploading).forEach(_key => {								if (_key != key) {									newState[_key] = ps.uploading[_key]								}							})							return {uploading: newState}						})						// Give the database the URL						this.db.child('song_urls/' + key).set(ss.downloadURL)						// Tell the db it is no longer pending						sPendingRef.remove()						sUploadedRef.set(true)						sDataRef.update({pending: false})						//Turn off disconnection listener						sPendingRef.onDisconnect().cancel()					})				})			})		}	}	getMetadata(file, settings = {}) {		return import('musicmetadata').then(mm => {			return new Promise((res, rej) => {				mm(file, settings, ((err, metadata) => {					err && rej(err)					res(metadata)				}))			})		})	}	componentWillMount() {		let userRef = this.db.child('room_data/' + this.roomId + '/users/' + this.user.uid)		userRef.set({			displayName: this.user.displayName		})		userRef.onDisconnect().remove()	}	componentDidMount() {		// Initial public room info		this.db.child('rooms/' + this.roomId).once('value').then(data => {			if (data.val() === null) {				this.setState({nullPage: true})			}			this.setState({...data.val()})		})		// Track queue changes		let time = Date.now()		this.db.child('room_data/' + this.roomId + '/songs').on('value', data => {			if (data.exists()) {				const newTime = Date.now()				let promises = []				Object.keys({...data.val().pending, ...data.val().uploaded}).forEach(sId => {					console.log(sId)					promises.push(this.db.child('song_data/' + this.roomId + '/' + sId).once('value')					.then(songD => {						return songD.val()					}))				})				// Only update with the latest r_d value regardless of how fast the s_d come back				Promise.all(promises).then(songs => {					if (newTime > time) {						this.setState({songs: songs})						time = newTime					}				})			} else {				this.setState({songs: {}})			}		})		// Track current track changes		this.db.child('room_data/' + this.roomId + '/current_track').on('value', ss => {			if (ss.exists()) {				this.setState({					playFrom:  Math.max(Date.now() - ss.val().startedAt, 0),					isPlaying: true,				})			} else {				this.trackEnded()			}			this.setState({current_track: {...ss.val()}})		})	}	isDoneLoading() {		return this.state.current_track !== undefined &&			this.state.songs !== undefined &&			this.state.room_name !== undefined	}	componentWillUnmount() {		clearInterval(this.progressUpdateInterval)		this.db.off()		this.db.child('room_data/' + this.roomId + '/users').off()		this.db.child('room_data/' + this.roomId + '/users/' + this.user.uid).remove()	}	trackEnded() {		this.setState({isPlaying: false})		clearInterval(this.progressUpdateInterval)		this.progressUpdateInterval = null		let oReq = new XMLHttpRequest();		let url = "https://us-central1-aux-io.cloudfunctions.net/trackEnded"		url += `?roomId=${this.roomId}`		oReq.open("GET", url);		oReq.send();	}	onPlaying(smo) {		//SM gets duration so we can use that and skip the MM parse for it		if (this.state.current_track && !this.state.current_track.duration) {			this.setState({current_track: Object.assign(this.state.current_track, {duration: smo.duration})})		}	}	render() {		if (this.isDoneLoading()) {			let uploadMessage = 'Upload'			if (this.state.uploading && Object.keys(this.state.uploading).length) {				uploadMessage = Object.keys(this.state.uploading).map(key => {					const track = this.state.uploading[key]					return (						<div className="img-with-overlay" key={key}>							<img								src={track.albumURL}								alt=""							/>							<div className="img-overlay">								<ProgressBarUpload.Circle									progress={track.bytesTransferred / track.totalBytes}									options={{										color:       '#560e0e',										strokeWidth: 20,										trailColor:  'transparent',									}}								/>							</div>						</div>					)				})			}			if (this.state.songs) {				//noinspection ES6ConvertVarToLetConst				var queueData = [...this.state.songs]			} else {				queueData = []			}			return (				<div id="room-container">					<Player						url={this.state.current_track.url || ''}						//playFromPosition={Date.now() - this.props.startedAt}						playFromPosition={this.state.playFrom}						playStatus={this.state.isPlaying ? 'PLAYING' : 'STOPPED'}						onFinishedPlaying={this.trackEnded}						onPlaying={this.onPlaying}					/>					<div id="music">						<div id="now-playing">							<div id="img-container">								<img className="pic"									 alt="np_album"									 src={this.state.current_track.albumURL || '../../default.png'}								/>							</div>							<div id="right">								<MusicInfo {...this.state.current_track}/>								{this.state.current_track.title && <ProgressBarMusic									startedAt={this.state.current_track.startedAt}									duration={this.state.current_track.duration}								/>}								<div id="controls">									controls								</div>							</div>						</div>						<ReactTable							className="-striped queue"							data={queueData}							columns={Room.queueColumns}							resizable={true}							showPaginationBottom={false}							defaultSorted={[								{									id: 'pending',								},								{									id: 'title'								}							]}							noDataText="Upload a song to get started!"							getTrProps={(state, rowInfo) => {								if (!rowInfo || !rowInfo.row.pending) return true;								return {									className: 'pending'								}							}}						/>						<Upload							onDrop={this.handleUploads}							accept="audio/*"							style={{}}							id="upload"							//docs: https://react-dropzone.js.org/						>							<div className="img-uploading">								{uploadMessage}							</div>						</Upload>					</div>					<Chat						roomId={this.roomId}						user={this.user}/>				</div>			)		} else if (!this.state.nullPage) {			return <div id="room-container">				<Spinner name="line-scale" color="#560e0e" fadeIn="half" className="room-spinner"/>			</div>		} else {			return <div id="room-container">				invalid page			</div>		}	}}functionMusicInfo(props) {	let line1 = props.title	let line2 = props.artist	let line3 = <small>{props.album}, {props.year}</small>	if (props.title) {		return (			<div id="music-info">				{line1}<br/>				{line2}<br/>				{line2 && line3}			</div>		)	} else {		return <div id="music-info">Nothing at the moment</div>	}}export default Room